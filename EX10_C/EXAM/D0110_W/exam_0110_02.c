// =========================================================================
//                 DOUBLE POINTER & VOID POINTER 
// =========================================================================
#include <stdio.h>
#include <stdlib.h>
// -------------------------------------------------------------------------
// [이중 포인터] 1.
// int형 변수 x=10을 선언하고,
// int* p = &x, int** pp = &p 를 만든 뒤,
// **pp를 이용해 x 값을 99로 변경하고 출력하세요.
// -------------------------------------------------------------------------
//int main(void)
//{
//	int x = 10;
//	int* p = &x;
//	int** pp = &p;
//
//	**pp = 99;
//	printf("바뀐 값 : %d", x);
//}

// -------------------------------------------------------------------------
// [이중 포인터] 2.
// swap 함수를 "이중 포인터" 버전으로 작성하세요.
// 요구: main에서 int a=1, b=2; int *pa=&a, *pb=&b; 로 준비한 뒤
//      swap_pp(&pa, &pb); 호출 후 pa/pb가 서로 바뀌었는지 확인 출력.
// -------------------------------------------------------------------------
//void swap_pp(int** a, int** b)
//{
//	int* temp = *a;
//	*a = *b;
//	*b = temp;
//}
//int main(void)
//{
//	int a = 1, b = 2;
//	int* pa = &a;
//	int* pb = &b;
//	printf("바꾸기 전 : %d, %d\n", *pa, *pb);
//
//	swap_pp(&pa, &pb);
//
//	printf("바꾼 후 : %d, %d\n", *pa, *pb);
//}

// -------------------------------------------------------------------------
// [이중 포인터] 3.
// 동적 할당으로 int 배열 n개를 만들고, 그 주소를 반환하는 함수를 구현하세요.
// 조건:
// - make_array(&p, n) 호출 시 p가 n개 int를 가리키도록 malloc
// - 할당 실패 시 0 반환, 성공 시 1 반환
//
// -------------------------------------------------------------------------
//int make_array(int** p, int n)
//{
//	*p = (int*)malloc(sizeof(int) * n);
//
//	if (*p == NULL)
//		return 0;
//
//	return 1;
//}
//int main(void)
//{
//	int* p = NULL;
//	int n = 5;
//
//    if (!make_array(&p, n))
//    {
//        printf("메모리 할당 실패\n");
//        return 1;
//    }
//
//    for (int i = 0; i < n; i++)
//        p[i] = (i + 1) * 10;
//
//    for (int i = 0; i < n; i++)
//        printf("%d ", p[i]);
//    printf("\n");
//
//    free(p);
//    return 0;
//}


// -------------------------------------------------------------------------
// [이중 포인터] 4.
// 문자열 리터럴을 가리키는 포인터 배열을 선언하세요.
// 예: {"Good","Bad","Nice"} 처럼 3개 문자열.
// 그리고 첫 문자열의 첫 글자('G')와 두 번째 문자열 전체("Bad")를 출력하세요.
// -------------------------------------------------------------------------
//int main(void)
//{
//	char* str[] = { "Good", "Bad", "Nice" };
//
//	printf("첫 문자열의 첫 글자 : %c\n", str[0][0]);
//	printf("두 번째 문자열의 전체 : %s", str[1]);
//
//	return 0;
//	
//}



// -------------------------------------------------------------------------
// [void 포인터] 5.
// int a=10; double b=3.14; 를 선언하고,
// void* vp에 각각의 주소를 대입해가며 값을 출력하세요.
// -------------------------------------------------------------------------
//int main(void)
//{
//	int a = 10;
//	double b = 3.14;
//	void* vp;
//
//	vp = &a;
//	printf("a의 값은 %d\n", *(int*)vp);
//
//	vp = &b;
//	printf("b의 값은 %lf", *(double*)vp);
//
//	return 0;
//}



// -------------------------------------------------------------------------
// [void 포인터] 6.
// 서로 다른 타입의 주소들을 저장하고, 저장된 순서대로 값과 주소를 출력하는 코드를 
// 작성하세요.
// - 데이터 : int a=7; double b=2.5; char c='Z';
// -------------------------------------------------------------------------
//int main(void)
//{
//	int a = 7;
//	double b = 2.5;
//	char c = 'Z';
//
//	void* p[3];
//	p[0] = &a;
//	p[1] = &b;
//	p[2] = &c;
//
//	printf("값 : %d, 주소 : %p\n", *(int*)p[0], p[0]);
//	printf("값 : %lf, 주소 : %p\n", *(double*)p[1], p[1]);
//	printf("값 : %c, 주소 : %p\n", *(char*)p[2], p[2]);
//}


